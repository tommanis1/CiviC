Language "CIVIC"

[
  Type all-values
  Funcon self
  
  Funcon thread-sleep
]

//Funcon counter() :=> null-type ~>sync-create(
//    sync-count,
//    sync-waiting-map
//    
//	)
//
//Funcon
//  sync-feature-create(_:sync-features) : =>sync-feature-maps
//Rule
//  sync-feature-create sync-waiting-list ~>
//    { sync-waiting-map |-> 
//       allocate-initialised-variable(maps(thread-ids,_), map()) }
//       
//        
//Funcon
//  sleep-sync(SY:syncs) : =>null-type
//   ~> thread-atomic sequential(
//        check-true not(assigned sync-feature(SY, sync-held)),
//        assign(, map-unite(sync-feature(SY, sync-count), ))
////        ,
////        assign(sync-feature(SY, sync-holder), current-thread)
//        )

//Funcon sleep-increment(SY:syncs) : =>null-type ~> thread-atomic sequential(
//	assign(sync-feature(SY, sync-count), nat-succ(sync-feature(SY, sync-count)))
//)

Funcon print-debug : => booleans ~> false
Funcon
  overload-multithread(_:=>values) : =>values
  
Rule
  overload-multithread X ~>
    sequential(
      overload-initialise-multithreading,
      give(
        thread-activate thread-joinable thunk closure X, // gives TI
        handle-abrupt(
          sequential(
            while-true(or(is-some-thread-active, is-some-thread-sleeping),
           		sequential(
           			if-else(and(is-equal(set-size current-active-thread-set, 0), is-some-thread-sleeping),
           				force-wake tuple-elements sleeping-threads-lowest-v map-elements current-sleep-map,
           				null
           			),
           			update-thread-stepping,
           				sequential(
           				handle-abrupt(
           					thread-step, 
           					sequential(print("thread-step failed"))),
           				increment-n-steps,
           				foreach-thread-try-wake map-elements current-sleep-map
           				)
//           			),
           			
//					handle-abrupt(
//           					sequential(
//           						update-thread-stepping, 
//           						thread-step, 
//           						increment-n-steps,
//           						foreach-thread-try-wake map-elements current-sleep-map
//           					),
//           					sequential(
//           						print(tuple("caught deadlock", is-some-thread-sleeping)),
//           						if-else(
//           							is-some-thread-sleeping,
//           							force-wake tuple-elements sleeping-threads-lowest-v map-elements current-sleep-map,
//           							null //abrupt(given)
//           						)
//           					)
//           				),
//           				,print(tuple("multi2","thre:", current-thread-stepping, is-some-thread-active, is-some-thread-sleeping, current-active-thread-set, is-some-thread-suspended))
              		)
              	),
              	handle-abrupt(check not is-some-thread-suspended, abrupt "deadlock"), // deadlock
            thread-value given), // given is TI
          given) // given is the reason for abruption
          ))
          
              		
//              		thread-atomic 
//              		sequential(
////              		print(current-sleep-map),
//					if-else(is-some-thread-sleeping,
//              				foreach-thread-try-wake map-elements current-sleep-map, null
//              		),
//              				
//              		if-else(and(not is-some-thread-active, is-some-thread-sleeping),
//						force-wake tuple-elements sleeping-threads-lowest-v map-elements current-sleep-map, 
//						null
//              		)
//              		)
//              		
//              		,
              		
              		
//              		increment-n-steps
//              		update-thread-stepping, thread-step, 
//              		increment-n-steps
//              		,
////              		thread-atomic 
//              		sequential(
//              		print(current-n-steps),
////              		print("test"),
//              		print(current-sleep-map),
//              		,
//              		print map-elements current-sleep-map,
//              		foreach-thread-try-wake map-elements current-sleep-map
//          			print("here")
//              		),
//              		print("tt")
//              		,
////              		,
//////              		wakeup-sleeping-threads,
//	              	if-else(and(not is-some-thread-active, is-some-thread-sleeping),
////	              		set-n-steps-to()
////	              		wakeup-
//						force-wake tuple-elements sleeping-threads-lowest-v map-elements current-sleep-map ,
//              			null
////              	)
//              ))),
//              
              
//            check not is-some-thread-suspended, // deadlock
//            thread-value given), // given is TI
//          given) // given is the reason for abruption
//      ))


Funcon
  condition-wait-with-lock-overload(SY:syncs, L:syncs) : =>null-type
   ~> sequential(
         thread-atomic sequential(
          exclusive-lock-release(L),
          sync-waiting-list-add(SY, current-thread),
          thread-suspend current-thread),
        exclusive-lock-sync-else-wait(L))
        
Funcon
  overload-initialise-multithreading : =>null-type ~>
  sequential(
    initialise-thread-map,
    initialise-active-thread-set,
    initialise-thread-stepping,
    initialise-terminated-thread-map,
    initialise-thread-schedule,
    initialise-n-steps,
    initialise-sleep-map
  )

//Meta-variables
//  GT <: ground-values
//  T? <: values?
//  
 
 Type values-or-thread-ids ~> thread-ids
						| values
						
Funcon foreach-thread-try-wake(_:(tuples(ints, syncs))*) : => null-type
Rule foreach-thread-try-wake() ~> null
Rule foreach-thread-try-wake(tuple(V:ints, S:syncs), T*:(tuples(ints, syncs))*) ~> 
//	thread-atomic 
	sequential(
//		print(tuple("foreach-thread-try-wake", tuple(V, S), tuple(T*))),
		try-wake(V,S), 
//		if-else( print-debug,
//		print("continueing"),
//		null),
		foreach-thread-try-wake(T*)
	)

						
Funcon sleeping-threads-lowest-v(_:(tuples(ints, syncs))*) : => tuples(ints, syncs)
Rule sleeping-threads-lowest-v() ~> tuple()

Rule sleeping-threads-lowest-v(tuple(V:ints, S:syncs)) ~> tuple(V, S)
Rule sleeping-threads-lowest-v(tuple(V1:ints, S1:syncs), tuple(V2:ints, S2:syncs), T*:(tuples(ints,syncs))* ) ~> 
//	thread-atomic 
	sequential(
//	if-else( print-debug,
//	print("tuple-elements sleeping-threads-lowest-v map-elements current-sleep-map"),
//	null),
	if-else(is-less(V2, V1),
		sleeping-threads-lowest-v(tuple(V2, S2), T*),
		sleeping-threads-lowest-v(tuple(V1, S1), T*)
	))



Funcon try-wake(V:ints, S:syncs) :=> null-type ~>
//	thread-atomic
	 sequential(
//	 print(tuple("woke", V)),
//	print(tuple("try-wake", V, S, "\n")),
	if-else(is-greater-or-equal(current-n-steps, V),
		sequential(
			thread-wake(V, S)
		),
		null
	))

//Funcon force-wake(_:thread-ids?, _:ints?) :=> null-type
Funcon force-wake(_:ints _:syncs) :=> null-type

//Rule  force-wake() ~> null
Rule  force-wake(V:ints, S:syncs) ~>
	sequential(
		n-steps-set(V),
		thread-wake(V, S)
	)
//
// Suspend I for V steps

//if there is already a thread waiting to resume at the same time, wait on the same condition, 
//Otherwise
//	if(is-equal(map-elements current-sleep-map, tuple)
//	print(tuple("Funcon thread-sleep", current-sleep-map, is-equal(tuple lookup(current-sleep-map, V), tuple))),
//	give(lookup(current-sleep-map, V), 
//		 sequential (
//		print(tuple("0", given))
//		,
//		if-else(is-equal(tuple given, tuple),
//			give(condition-create,
//				sequential(
//					print(tuple("1", given)),
//					add-to-sleep-map(V, given),
//					condition-wait given
//				)
//			),
//			condition-wait given 
//			)
//		)
	
//	),
//	print("done setting up sleep")
//	))
//	if-else() 
//if-else( print-debug,
//	 print("b thread-sleep"),
//	 null),
//	add-to-sleep-map(I,int-add(current-n-steps, V)),
//	if-else( print-debug,
//		print(tuple("added-to=ma", I)),
//		null),
//	
//	thread-suspend(I),
//	if-else( print-debug,
//	print("sis"),
//	null)
//	
//	)
	
//Funcon try-wake(_:thread-ids, _:ints) : => null-type
//Funcon thread-wakeup

// map-elements
//Funcon
//  thread-wakeup-time-passed(_:thread-ids*) : =>null-type
//Rule
//  is-in-set(TI, {TI*}) == (false)
//  set-intersect(ATS, {TI*}) == { }
//  set-unite(ATS, {TI*}) ~> ATS′
//  -------------------------------------------------------------------------------
//  < thread-resume(TI*:thread-ids*), thread-stepping(TI), active-thread-set(ATS) >
//    ---> < null-value, thread-stepping(TI), active-thread-set(ATS′) >
//    
Type all-values ~> functions(tuples(values*),values)
						| values
						| syncs
						


//## Object atributes
// 
//Funcon pattern-from-ids(_:ids*) : => natural-numbers
//Rule pattern-from-ids() ~> 0
//Rule pattern-from-ids(I:ids, I*:ids*) ~> pattern abstraction{ I |->allocate-initialised-variable ( values, given ) }, pattern-from-ids(I*)


Funcon method-zero-params(_:=>values) : =>functions(_, _)


Rule method-zero-params(X) ~>       
	function closure scope(
		collateral ( // TODO, remove?? variables not allowed to shadow visible fields
	      match ( given,
	        tuple (
	          pattern abstraction
	            { "self" |->
	              allocate-initialised-variable ( pointers(objects), given ) }
	              ) ),
	      object-single-inheritance-feature-map 
	        checked dereference first tuple-elements given
	        ),
	       	sequential(X)
	    )
Funcon self(I:ids) :=> vars ~>
	lookup(object-single-inheritance-feature-map checked dereference assigned bound "self", I)
	
Funcon method(_:=>values, _:(=>values)?) : =>functions(_, _)
Rule method(X, U?) ~>       
	function closure scope(
		collateral ( // TODO, remove?? variables not allowed to shadow visible fields
	      match ( given,
	        tuple (
	          pattern abstraction
	            { "self" |->
	              allocate-initialised-variable ( pointers(objects), given ) }, U?
	              ) ),
	      object-single-inheritance-feature-map 
	        checked dereference first tuple-elements given
	        ),
	       	handle-return(sequential(X))
	    )
//Funcon method-zero-params(_:=>values, _:ids*) : =>functions(_, _)

//Funcon 
//pattern closure
Funcon unpack(_:ids*) : => patterns* // TODO what instead of null-type
//Rule unpack(I:ids) ~> print(I)
//pattern abstraction(bind(I,alloc-init(values, given)))

Rule unpack(I:ids, I*:ids*) ~> (pattern abstraction(bind(I,alloc-init(values, given))), unpack(I*))
Rule unpack()~> ()

Funcon simple-class(_:ids, _:envs, _:envs) : => classes
Rule simple-class(I:ids, V:envs, F:envs) ~> 
	class(thunk closure reference object (fresh-atom, I, V), F)

Funcon extend-object-map(_:objects, _:environments) :=> objects
Rule extend-object-map(O:objects, Env:environments) ~>
object(
fresh-atom,
object-class-name O,
map-unite(
object-feature-map O,
Env
))

Funcon get-class-method(O:objects, I:ids) :=> values ~>
 checked lookup (
//        lookup the method
          class-feature-map checked lookup
                                   (assigned
                                      (bound
                                         ("_std")),
                                    object-class-name O),
                                    I)
	      
//## Future
//Funcon
//
//async-fun-create(F:thunks(T)) : => promise(T)  
//	~> 
//	give(promise-create, 
//		thread-activate thread-detached 
//			 thunk(closure(
//			promise-set-value(enact(F), given)
//			))
////			promise-set-value(handle-return force F, given)
//	)

//	promise = promise-create
//	scope promose?
//	spawn thread with promise in scope
//	call thunk in thread with promise in scope
//	allocate-index thread-activate thread-joinable postpone-after-effect 
//	
//	promise-set-value(return value, promise)
//	handle-return(F) //gives value V
	
//
//supply(_:functions(T, T′), _:T) : =>thunks(T′
//	
//
//return promise 
//
//maps(id, values)

Type values-or-syncs ~> values | syncs
						
//records(syncs)
Datatype
  shared-state-features ::=
    cv |
    mtx |
    state |
    is-set
Auxiliary Type
  shared-state ~> maps(shared-state-features, values-or-syncs)
  
 Funcon shared-state-create : =>  shared-state
  ~>
  {
  	cv |->  alloc-init(syncs, condition-create),
  	mtx |-> alloc-init(syncs, exclusive-lock-create),
  	state |-> alloc-init(values, null),
  	is-set |-> alloc-init(booleans, false)
  }

  
//  maps(identifiers, values-or-syncs) ~> {
//   "cv" |-> condition-create
//   "mtx" |-> exclusive-lock-create
//   "shared_state" |-> exclusive-lock-create
//   }
//   
//  
//   
//  
//Funcon promise-feature (_:promise, _:promise-features) ~>
//Rule
//  promise-feature(sync(SFM:sync-feature-maps), SF:sync-features)
//   ~> checked map-lookup(SFM, SF)
   
//checked map-lookup(SFM, SF)

Funcon shared-state-get(P:shared-state) : => values ~>
	 if-else(assigned checked map-lookup(P, is-set), 
		assigned checked map-lookup(P, state),
		    sequential(
			condition-wait(assigned checked map-lookup(P, cv)),
			assigned checked map-lookup(P, state)
		)
	)
//	if 
//	sequential(
//		condition-wait-with-lock(assigned checked map-lookup(P, cv), assigned checked map-lookup(P, mtx)),
//		C
//		,
//		exclusive-lock-release(assigned checked map-lookup(P, mtx))
//	)

Funcon shared-state-set(P:shared-state, V:values) : => null-type  ~> 
	thread-atomic if-else(assigned checked map-lookup(P, is-set),
		null
		thread-atomic sequential (
			assign(checked map-lookup(P, state), V),//	set value
			assign(checked map-lookup(P, is-set), true),//	set value
	//		exclusive-lock-release(assigned checked map-lookup(P, mtx)),
			condition-notify-all assigned checked map-lookup(P, cv)
		)
	)

Meta-variables
  T <: values
  T* <: values*
  
Funcon tuple-head(_:tuples(values*)) : =>tuples(values*)
Rule tuple-head(tuple( )) ~> ( )
Rule tuple-head(tuple(V:T, V*:T*)) ~> V

Funcon tuple-tail(_:tuples(values*)) : =>tuples(values*)
Rule tuple-tail(tuple( )) ~> ( )
Rule tuple-tail(tuple(V:T, V*:T*)) ~> tuple(V*:T*)

//## Sleep
//### Steps

Entity
  < _ , n-steps(_:ints) > --->
  < _ , n-steps(_:ints) >

Auxiliary Funcon
  initialise-n-steps : =>null-type

Rule
  initialise-n-steps
    ---> < null-value,  n-steps(0)>

Funcon
  current-n-steps : =>ints
Rule
  < current-n-steps, n-steps(T) > ---> T

Funcon n-steps-set(_:ints) : =>null-type
Rule
  < n-steps-set(V:ints), n-steps(T) > ---> < null, n-steps(V)>

Funcon increment-n-steps : =>null-type
Rule
  < increment-n-steps, n-steps(T) > ---> < null, n-steps(nat-succ T) >
  
//### Sleep map
Entity
  < _ ,  sleep-map(_:maps(ints, syncs)) > --->
  < _ ,  sleep-map(_:maps(ints,syncs)) >
  
Auxiliary Funcon
  initialise-sleep-map : =>null-type

Rule
  initialise-sleep-map
    ---> < null-value, sleep-map(map()) >


Funcon add-to-sleep-map(_:ints, _:syncs) :=> null-type
Rule <add-to-sleep-map(V:ints, S:syncs), sleep-map(M)> ---> < null-value, sleep-map(map-unite({V|->S}, M)) >

Funcon remove-from-sleep-map(_:ints) :=> null-type
Rule <remove-from-sleep-map(V:ints), sleep-map(M)> --->  < null-value, sleep-map(map-delete(M, set(V))) >

Funcon current-sleep-map : =>maps(ints, syncs)
Rule < current-sleep-map, sleep-map(M) > ---> M

//Rule
//  < current-sleep-map, sleep-map( ) > ---> fail
  
Funcon
  is-some-thread-sleeping : =>booleans ~> not is-equal(tuple map-elements current-sleep-map, tuple())
  
Funcon set-size-active-thread-set : => ints
Rule
  < set-size-active-thread-set, active-thread-set(ATS) >
    ---> set-size(ATS)

Funcon current-active-thread-set : => sets(thread-ids)
Rule < current-active-thread-set, active-thread-set(M) > ---> M

Funcon current-thread-stepping : => thread-ids?
Rule < current-thread-stepping, thread-stepping(TI) > ---> TI
Rule < current-thread-stepping, thread-stepping() > ---> "empty"

Funcon
  thread-resume-no-checks(_:thread-ids*) : =>null-type
Rule
//  is-in-set(TI, {TI*}) == (false)
//  set-intersect(ATS, {TI*}) == { }
//  -------------------------------------
  
  < thread-resume-no-checks(TI*:thread-ids*), active-thread-set(ATS) >
    ---> < null-value, active-thread-set(set-unite(ATS, {TI*})) >
    
////
// thread-stepping(TI)
//   not is-equal(current-sleep-map, {})
//Rule
//  < is-some-thread-sleeping, sleep-map(M) >
//    ---> not is-equal(map-elements M, map-elements map())
//    
Funcon thread-wake(V:ints, S:syncs) : => null-type ~> 
//	thread-atomic 
	sequential(
		remove-from-sleep-map(V),
		overload-condition-notify-all(S)
)

Funcon
  overload-condition-notify-all(SY:syncs) : =>null-type
   ~> 
//   thread-atomic
    sequential(
//        	print("overload-condition-notify-all"),
          thread-resume-no-checks list-elements
            assigned sync-feature(SY, sync-waiting-list),
          assign(sync-feature(SY, sync-waiting-list), []))
          
	//	,
//	thread-atomic 
//	sequential(
//	thread-resume(I)
//	,
//	print "resumed"
//	)
//	,
//	null
//)

//Rule
//	is-in-set(TI, {TI+}) == (false)
//	map-unite({I |-> V}, M) ~> M′
//	-------------------------------------------------------------------------------
//	<add-to-sleep-map(I:thread-ids, V:ints), sleep-map(M)> ---> <sleep-map(map-unite({I |-> V}, M))>
	 
	 
//	 map-unite
//Entity
//  < _ , wake-map(_:maps(thread-ids, ints)) > --->
//  < _ , wake-map(_:maps(thread-ids, ints)) >
  
//Funcon
//  current-time-passed : =>ints
//Rule
//  < current-time-passed,  time-passed(I) >
//    ---> I
    
//Auxiliary Funcon
//  initialise-time-passed : =>null-type
//
//Rule
//  initialise-time-passed
//    ---> < null-value, decimal-natural("0") >

//Entity time-passed(_: ints) |- _ ---> _

//Auxiliary Funcon
//  initialise-time-passed : =>null-type
//
//Rule
//  initialise-time-passed time-passed(v: integers) |- _ ---> _
//    

//Funcon test(_:strings) : =>null-type
//Rule test(S:"test") ~> true
//Otherwise
//	test(_:strings) ~> false

//Datatype
//  libs ::= 
//  	shared-mutex-lib |
//  	mutex-lib
//
//Datatype literal-string-to-lib ::= {
//inlude-mutex |-> mutex-lib
//}
//
//(_:strings) :=> maps("strings", libs)
//Rule 
//
//Funcon lib-map(_:libs) :=>  maps(_,_)
//Rule lib-map mutex-lib ~> {"mutex" |-> "a"}
//Rule lib-map shared-mutex-lib ~> {"shared_mutex" |-> "a"}
//
//Funcon search-libs-in-program(_:strings) :=> libs*
//Rule search-libs-in-program(P:strings) ~> 

// Lexis
//Funcon tokens():=> lists(strings) ~> [
//	t-pound,
//	t-lower,
//	t-greater,
//	t-include,
//	t-mutex
//]
//
//Funcon t-pound():=> strings ~> "#"
//Funcon t-lower():=> strings ~> "<"
//Funcon t-greater():=> strings ~> ">"
//Funcon t-include():=> strings ~> "include"
//Funcon t-mutex():=> strings ~> "mutex"
//
//Funcon parser(S:strings):=> libs* ~>
//	sequential(
//		scope(
//			sequential(
//				bind("b", alloc-init(values,decimal-natural("0")))
//				bind("e", alloc-init(vales,decimal-natural("1")))
//			)
//		while()
//	
//	)
//Funcon is-sequence-

//Funcon include-mutex-lib():=> maps(_:_) ~>
//	{"test" |-> true}
//
//Funcon trans():=> null-type() ~> {
//	t-pound t-include t-greater t-mutex
//}
//Funcon tokenize(_:strings) :=> 

  
//     exclusive-lock-create : =>syncs
//   ~> sync-create(
//        sync-feature-create sync-waiting-list,
//        sync-feature-create sync-held,
//        sync-feature-create sync-holder)
        
//   condition-create //create cv
   
   
//   Funcon
//  condition-create : =>syncs
//   ~> sync-create(
//        sync-feature-create sync-waiting-list)
    
//   condition-wait-with-lock(SY:syncs, L:syncs)


//Funcon
//  initialise-local-methods : => environments
//   ~> bind("local-methods", 
//        allocate-initialised-variable(environments, map( )))
////
//Funcon
//  local-variable(I:ids) : => variables
//   ~> checked lookup(assigned bound "local-variables", I)
//
//Funcon
//  local-method-declare(I:ids, F:functions(tuples(values*),values)) : => null-type
//   ~> assign(bound "local-methods", 
//        map-override(
//          { I |-> allocate-initialised-variable(functions(tuples(values*),values), F)},
//          assigned bound "local-methods"))

//Funcon
//  local-variable-assign(I:ids, V:values) : => null-type
//   ~> else(
//        assign(local-variable I, V),
//        local-variable-initialise(I, V))
//        
