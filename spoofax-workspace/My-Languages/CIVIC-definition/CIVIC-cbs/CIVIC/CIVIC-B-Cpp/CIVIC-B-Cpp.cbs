Language "CIVIC"

#B Cpp



Lexis
	CPP-Lib: cpp-std-lib ::= 'iostream' | 'thread' 	| 'mutex' | 'shared_mutex'	| 'future' | 'condition_variable' | 'chrono'
	CPPLibId : lib-id ::= 'std' ':' ':' ('A'-'Z'|'a'-'z'|'_')* ( ':' ':' ('A'-'Z'|'a'-'z'|'_')+)*
Syntax 
	CPPE : cpp-expr ::= id '.' id '(' exprs? ')'| lib-id | lib-id '(' exprs? ')'

Rule eval[[ CPPLibId ]] = lookup(assigned(bound("_std")), \"CPPLibId\")
Rule eval[[ ID1 '.' ID2 '(' ')' ]] = 

 give ( assigned bound(id[[ ID1]]),
      apply (
        lookup (
//        lookup the method
          class-feature-map lookup
                                   (assigned
                                      (bound
                                         ("_std")),
                                    object-class-name checked dereference given),   //class name                                  
          id[[ID2]] ),
        tuple ( given, () ) ) )

Rule eval[[ ID1 '.' ID2 '(' Exprs ')' ]] = 
 give ( assigned bound(id[[ ID1]]),
      apply (
        lookup (
//        lookup the method
          class-feature-map lookup
                                   (assigned
                                      (bound
                                         ("_std")),
                                    object-class-name checked dereference given),   //class name                                  
          id[[ID2]] ),
        tuple ( given, tuple(eval-exprs[[ Exprs ]]) ) ) )
        
Rule eval [[ CPPLibId '(' Exprs? ')' ]] = 
apply(
	lookup(assigned(bound("_std")),\"CPPLibId\"),
	tuple(eval-exprs[[ Exprs? ]]))

//Rule eval [[ CPPLibId '('  ')' ]] = 
//apply(
//	lookup(assigned(bound("_std")),\"CPPLibId\"),
//	tuple(()))

Syntax
	CPPDDecl : cpp-decl ::= 'include' '<' cpp-std-lib '>'
Rule declare[[ CPPDDecl ]] = ()
Rule initialise[[ CPPDDecl ]] = ()

Rule initialise-lib[[ 'include' '<' 'iostream' '>' ]] = assign(bound "_std", map-unite(assigned(bound("_std")),
{	
	"std::endl" |-> "\n"
}))
Rule initialise-lib[[ 'include' '<' 'condition_variable' '>' ]] = assign(bound "_std", map-unite(assigned(bound("_std")),
{
	"std::condition_variable" |-> simple-class("std::condition_variable", 
	{"" |->""}, {
	"(constructor)" |-> method(reference extend-object-map(
		                    dereference force class-instantiator lookup(assigned(bound("_std")), "std::condition_variable"),
		                    {
			                    "condition" |-> alloc-init(syncs, condition-create)
		                    })),
	"wait" |-> method(
		if-else(
			is-equal(object-class-name dereference assigned bound "unique_lock", "std::unique_lock"),
			sequential(
					//assign(lookup(object-single-inheritance-feature-map checked dereference assigned bound "unique_lock", "owns"), false),
					//give(assigned lookup(object-single-inheritance-feature-map checked dereference assigned bound "unique_lock", "mutex-ref"), // get mutex object in unique_lock
					//give(assigned lookup(object-single-inheritance-feature-map checked dereference given, "mutex"), // get  exclusive-lock funcon in mutex object 
					give(assigned bound "unique_lock",sequential(
					//TODO wait with lock instead
//					apply(get-class-method( dereference given, "unlock"), tuple(given)),
					condition-wait assigned self "condition"
//					,
//					apply(get-class-method( dereference given, "lock"), tuple(given))
					
					))
//					, given))
				),
			throw "need std::unique_lock"
		)
	, tuple(unpack "unique_lock")),
	"notify_all" |-> method(condition-notify-all(assigned self "condition"))
	
	})
}))
Rule initialise-lib[[ 'include' '<' 'mutex' '>' ]] = assign(bound "_std", map-unite(assigned(bound("_std")),
{
	"std::mutex" |-> simple-class("std::mutex", 
		{ "" |->"" },
	    {
	    "(constructor)" |-> method(reference extend-object-map(
            dereference assigned bound "self",
            {
                "mutex" |-> allocate-initialised-variable(syncs, exclusive-lock-create),
                "locked" |-> alloc-init(booleans, false)
                
            })),
	    	"lock" |-> method(sequential(exclusive-lock-sync-else-wait(assigned self "mutex"), assign( self "locked", true), print "", return null)),
	    	"unlock" |-> method(sequential(
	    		if-else( assigned self "locked",
	    			sequential(
	    				exclusive-lock-release(assigned self "mutex"),
	    				assign(self "locked", false)
	    			),
	    			null
	    		),
	    		return null))
	    }
	),
	"std::unique_lock" |-> simple-class("std::unique_lock",
        {""|->""},
        {
        "(constructor)" |-> method(
                sequential(
                    give(extend-object-map(
		                    dereference assigned bound "self",
		                    {"owns" |-> allocate-initialised-variable(booleans, false),
			                  "mutex-ref" |-> alloc-init(values, assigned bound "mutex-ref")}),
                		// given is the just created unique_lock object
                		sequential(
                		// call lock on the unique_lock
                		apply(get-class-method( given, "lock"), tuple(reference given)),
                		reference given
                		)
                	)),
                tuple(unpack "mutex-ref")
//            )
            ),
            	"(destructor)"  |-> method(
		give(assigned bound "self", 
			apply(get-class-method( dereference given, "unlock"), tuple(given))
		)
	),
            "lock" |-> method(
            	  if-else(
                    assigned(self "owns"),
                    throw "already owns lock",
                    sequential(
		            	give(  	// call lock on the associated lockable object
		            		assigned self "mutex-ref",
		                	apply(get-class-method(dereference given ,"lock"), tuple(given))
		                ),
		                assign(self "owns", true)
                    )
                )
            ),
            "unlock" |-> method(sequential(
            give(
		            		assigned self "mutex-ref",
		                	apply(get-class-method(dereference given ,"unlock"), tuple(given))
		                ), assign(self "owns", false))
            )
//            ,
//            "unlock" |-> method(
//                
//            ),
//            "(destructor)" |-> method(
//                if-else(
//                    assigned(self "owns"),
//                    sequential(
//                        exclusive-lock-release(assigned self "mutex"),
//                        assign(self "owns", false)
//                    ),
//                    null
//                )
//            )
        }
    )
	
}))

Rule initialise-lib[[ 'include' '<' 'shared_mutex' '>' ]] = assign(bound "_std", map-unite(assigned(bound("_std")),
{
	"std::shared_mutex" |->  simple-class( "std::shared_mutex",
	{ "rw-lock" |-> allocate-initialised-variable(syncs, rw-lock-create) },
	{
		"(constructor)" |-> method(force class-instantiator lookup(assigned(bound("_std")), "std::shared_mutex")),
		"lock" |-> method (rw-lock-sync-exclusive-else-wait assigned self("rw-lock")),
	 	"lock_shared" |->method (rw-lock-sync-shared-else-wait assigned self("rw-lock")),
	  	"unlock" |-> method( rw-lock-release-exclusive assigned self("rw-lock")),
		"unlock_shared" |-> method( rw-lock-release-shared assigned self("rw-lock"))
 	}
 	)}))
Rule initialise-lib[[ 'include' '<' 'future' '>' ]] = assign(bound "_std", map-unite(assigned(bound("_std")),{
	"std::promise" |-> simple-class("std::promise",
	{"promise" |-> allocate-initialised-variable(shared-state, shared-state-create)},
	{
		"get" |-> method(shared-state-get assigned self "promise"),
 		"set" |->method(
        	sequential (shared-state-set(assigned self("promise"), assigned bound "val")), 
        	"val"
 		)
 	}),
	"std::packaged_task" |->   simple-class("std::packaged_task", {
		"shared-state" |-> allocate-initialised-variable(shared-state, shared-state-create),
		"_init" |-> tuple(unpack "callable")
		
	},
	{
	
	"get_future" |-> method(
		reference object(fresh-atom, "std::future", {"shared-state" |-> assigned self "shared-state"})),
	"_call" |-> method(shared-state-set(assigned self "shared-state", apply(assigned self "callable", assigned bound "args")) , "args")
	})
	,
	"std::future" |->simple-class("std::future",{"_init" |-> [unpack( "shared-state")]} ,{
	
	"get"|-> method-zero-params(shared-state-get( self "shared-state")) 
	})
//	,
//	"std::async" |-> function closure scope(match(given, tuple(unpack("args"))),
//		sequential(print(assigned bound "args"))
//	)
//	
}))

Rule initialise-lib[[ 'include' '<' 'chrono' '>' ]] = assign(bound "_std", map-unite(assigned(bound("_std")),{
	"std::chrono::seconds" |-> function closure
                 (scope
                    (match
                       (given,
                        tuple
                          (pattern closure(bind("n",alloc-init(ints,given))))),
                           sequential
                             ( int-mul(assigned bound "n", 10))
                             )),
   	"std::chrono::milliseconds" |-> function closure
                 (scope
                    (match
                       (given,
                        tuple
                          (pattern closure(bind("n",alloc-init(ints,given))))),
                           sequential
                             ( int-mul(assigned bound "n", 1))
                             ))
}))

Rule initialise-lib[[ 'include' '<' 'thread' '>' ]] = assign(bound "_std", map-unite(assigned(bound("_std")),{
	"std::this_thread::sleep_for" |->                function closure
                 (scope
                    (match
                       (given,
                        tuple
                          (pattern closure(bind("n",alloc-init(ints,given))))),
                           sequential
                             ( thread-sleep(cast(assigned bound "n", ints))
                             ))),
     
                             
	"std::thread" |-> simple-class("std::thread", {
	""|->""

	
	},{
	"(constructor)" |-> method(sequential(
		give(
		give(force class-instantiator lookup(assigned(bound("_std")), "std::thread"),
			reference extend-object-map(dereference given, {
			"detached" |-> alloc-init(booleans, false),
			"index" |-> 		
			alloc-init(values, 
				allocate-index thread-activate thread-joinable postpone-after-effect 
				supply(tuple-head assigned bound "args", tuple-tail assigned bound "args"))})
			
		),
		sequential(
//		thread-yield(),
		return given))), unpack "args"),
	
	
		"join" |-> method sequential (if-else(assigned self "detached",
			null,
			sequential(thread-join lookup-index assigned self "index" , print("")))),
		"detach" |-> method sequential(
			assign( self "detached", true),
			null
		),
		"(destructor)" |-> 
		method thread-atomic sequential(
		 if-else(
			or(
				assigned self "detached",
				is-thread-terminated lookup-index assigned self "index"
			),
			null,
			throw "terminate called without an active exception"
		)
//		print "out scope"
		)
		
//		sequential( 
//		print(assigned self "index"),
//		throw "terminate called without an active exception")
		}), 
//		thread-joinable
	"std::jthread" |-> simple-class("std::jthread", {
	""|->""
	},{
		"(constructor)" |-> method(sequential(
		give(force class-instantiator lookup(assigned(bound("_std")), "std::jthread"),
			reference extend-object-map(dereference given, {"index" |-> 		
			alloc-init(values, 
				allocate-index thread-activate thread-joinable postpone-after-effect 
				supply(tuple-head assigned bound "args", tuple-tail assigned bound "args"))})
			
		)), unpack "args"),
		
		"join" |-> method thread-join lookup-index assigned self "index"
		})
}))
     
//
////Rule initialise-lib[[ 'include' '<' 'future' '>' ]] = assign(bound "_std", map-unite(assigned(bound("_std")),
////{
////	"std::promise" |-> 
////	 class (
////        thunk closure           // class instantiator
////          reference
////	object(fresh-atom, "std::promise",
////{
////"promise" |-> allocate-initialised-variable(promise-feature-maps, promise-create)
////}
////          ),
////{
//// "set" |->
////      function closure scope(
////        collateral ( // variables not allowed to shadow visible fields
////          match ( given,
////            tuple (
////              pattern abstraction
////                { "self" |->
////                  allocate-initialised-variable ( pointers(objects), given ) },
////                
////                 pattern abstraction
////      { "val" |->
////        allocate-initialised-variable ( values, given ) }
////          
////                  ) ),
////          object-single-inheritance-feature-map 
////            checked dereference first tuple-elements given
////            ),
////        sequential (
////      	promise-set(assigned self("promise"), assigned bound "val")
//// )),
//// 
////  "get" |->
////      function closure scope(
////        collateral (
////          match ( given,
////            tuple (
////              pattern abstraction
////                { "self" |->
////                  allocate-initialised-variable ( pointers(objects), given ) }
////          
////                  ) ),
////          object-single-inheritance-feature-map 
////            checked dereference first tuple-elements given
////            ),
////        sequential (
////        promise-get assigned self "promise"
//// ))
//// }
////          )
////          ,
//
////	"std::packaged_task" |-> 
////	 class (
////        thunk closure           // class instantiator
////          reference
////	object(fresh-atom, "std::packaged_task",
////{
////"promise" |-> allocate-initialised-variable(promise-feature-maps, promise-create)
////}
////          ),
////{
//// "constructor" |->
////      function closure scope(
////        collateral ( // variables not allowed to shadow visible fields
////          match ( given,
////            tuple (
////              pattern abstraction
////                { "self" |->
////                  allocate-initialised-variable ( pointers(objects), given ) },
////                
////                 pattern abstraction
////      { "test" |->
////        allocate-initialised-variable ( values, given ) }
////          
////                  ) ),
////          object-single-inheritance-feature-map 
////            checked dereference first tuple-elements given
////            ),
////        sequential (
////      	promise-set(assigned self("promise"), assigned bound "val")
//// ))
//// }
////          )
////          ,
////"std::async" |-> function closure scope(
////
////)
//
//          
////          }))
//          
//
//          
////Rule initialise-lib[[ 'include' '<' 'condition_variable' '>' ]] = assign(bound "_std", map-unite(assigned(bound("_std")),
////{
////	"std::condition_variable" |-> 
////	 class (
////        thunk closure           // class instantiator
////          reference
////	object(fresh-atom, "std::condition_variable",
////{
////"cv" |-> allocate-initialised-variable(syncs, condition-create)
////}
////          ),
////             { "wait" |->
////      function closure
////        sequential (
////        condition-wait-with-lock(SY:syncs, L:syncs)
////        
////        exclusive-lock-sync-else-wait(assigned( lookup(object-single-inheritance-feature-map 
////            checked dereference first tuple-elements given, "cv")))
//// )
//// }
////          )
////          
////          }))

Otherwise initialise-lib[[ Decl ]] = ()

//assign(bound "_std", map-unite(assigned(bound("_std")),
//{
//	"std::thread" |-> allocate-index
//}))

Syntax
	Insert : insert ::= '<<' exp
	Inserts : inserts ::= insert inserts?
	CPPStmt : cpp-stmt ::= insertstmt
//							| id '.' 'lock' '(' ')' ';'
//							| id '.' 'unlock' '(' ')' ';'
//						| 'for' '(' vardecl ';' exp ';' exp ')' block
	types ::= basic-type (',' types)?
	FunSign : function-signature ::= return-type '(' types? ')'
	InsertStmt : insertstmt ::= 	lib-id inserts ';'
	CPPVarDecl : cpp-var-decl ::=  lib-id id ';'
									| lib-id id '{' exprs? '}' ';' //thread decl
//									| lib-id  id '' exp (',' exprs)? ')' ';'
									| lib-id '<' basic-type '>' id '=' exp ';'
//								| 'promise' '<<' basic-type '>>' id ';'
									//| lib-id id '(' exprs ')' ';'

//Semantics concat[[ _:inserts?]] : =>null-type
//Rule concat[[ '<<' E Inserts? ]] = string-append(to-string (eval[[ E ]]), concat[[ Inserts?]])
//Rule concat[[ ]] = ()
//for each Inserts run CPPLibId on 
//Rule [[ CPPLibId '<<' E Inserts ';' ]] : insertstmt = [[ CPPLibId '<<' E ';' CPPLibId Inserts ';' ]]
Rule exec[[ CPPLibId '<<' E Inserts ';']] = 
//sequential(
//												lookup(assigned(bound("_std")), \"CPPLibId\"), 
												print eval[[ E]],
												exec[[ CPPLibId  Inserts ';']]
//												)
Rule exec[[ CPPLibId '<<' E ';']] = print eval[[ E]]

Rule exec[[ CPPStmt Stmts ]] = sequential(exec[[ CPPStmt ]], exec[[ Stmts ]])

//Rule exec[[ CPPLibId 
//Todo, else for other lock types
//Rule exec[[ ID '.' 'lock' '(' ')' ';']] =  exclusive-lock-sync-else-wait(eval[[ ID ]])
//Rule exec[[ ID '.' 'unlock' '(' ')' ';']] = exclusive-lock-release(eval[[ ID ]])

//Rule exec[[ 'for' '(' VarDecl E1' ';' E2 ')' Block ]] = 
//scope(
//var-declare[[ VarDecl ]], 
//while(eval[[ E1 ]], sequential(exec[[E2 ';' ]], exec[[ Block ]]))
//)
//Rule var-declare[[ 'promise' '<<' BasicType '>>' ID ';']] = 
//bind(id[[ ID ]], allocate-initialised-variable(promise-feature-maps, promise-create))

Rule declare[[ CPPLibId ID ';']] = bind(id[[ ID ]], alloc( references(objects)))
Rule initialise[[ CPPLibId ID ';']] = assign( bound id[[ ID ]],
	give(object(fresh-atom, \"CPPLibId \", {"" |-> ""}), 
	apply(get-class-method(given,"(constructor)"), tuple(reference given))))
// packaged task
Rule declare[[ CPPLibId ID '{' Exprs '}' ';' ]] = bind(id[[ ID ]], alloc( references(objects)))
Rule initialise[[ CPPLibId ID '{' Exprs '}' ';' ]] = assign(bound id[[ ID ]], 
give(object(fresh-atom, \"CPPLibId \", {"" |-> ""}), 
	apply(get-class-method(given,"(constructor)"), tuple(reference given, tuple(eval-exprs[[Exprs]])))))
	
//reference give (
//	checked dereference force class-instantiator lookup(assigned(bound("_std")), \"CPPLibId\"), 
//	extend-object-map(given, 
//		match(tuple(eval[[Exprs]]), lookup (object-feature-map given, "_init"))
//	
//	))
	
//	)
//TODO clean 

Rule destruct[[ CPPLibId ID '{' Exprs '}' ';' ]] = give( 
//Lookup the (destructor) member function
else(
	lookup (
		class-feature-map lookup(
			assigned(bound("_std")), 
			object-class-name checked dereference assigned bound id[[ ID]]
		),   //class name                                  
	    "(destructor)" 
	),
	null
),
// If (destructor) a is member function call it otherwise do nothing
if-else(is-equal(given, null),
	null,
	apply(given , tuple(assigned bound id[[ ID]]))

))


Otherwise destruct[[ Decl ]] = ()


Rule exec[[CPPLibId ID '{' Exprs '}' ';']] = ()

Rule declare[[ CPPLibId '<' BasicType '>' ID '=' E ';' ]] = bind(id[[ ID ]],  alloc values )
Rule initialise[[ CPPLibId '<' BasicType '>' ID '=' E ';' ]] = assign(bound id[[ ID ]], eval[[ E ]])

Rule exec[[ CPPLibId '<' BasicType '>' ID '=' E ';' ]] = ()

//Rule declare[[ CPPLibId ID1 '{' ID2 '}' ';' ]] = bind(id[[ ID1 ]], allocate-initialised-variable(values ,  null))
//Rule initialise[[ CPPLibId ID1 '{' ID2 '}' ';' ]] = ()
//Rule declare[[ CPPLibId ID1 '{' ID2 ',' Exprs '}' ';']] = bind(id[[ ID1 ]], allocate-initialised-variable(values ,  null))
//Rule initialise[[ CPPLibId ID1 '{' ID2 ',' Exprs '}' ';']] = ()
//Rule var-declare[[ CPPLibId ID '(' Exprs ')' ';']] = 
//bind(id[[ ID ]],  force class-instantiator lookup(assigned(bound("_std")), \"CPPLibId\")  )
//Rule exec [[ CPPLibId ID '(' Exprs ')' ';']] = 
// give ( bound(id[[ ID]]),
//      apply (
//        lookup (
////        lookup the method
//          class-feature-map lookup
//                                   (assigned
//                                      (bound
//                                         ("_std")),
//                                    object-class-name checked dereference given),   //class name                                  
//          "constructor" ),
//        tuple ( given, (eval[[ Exprs ]]) ) ) )

//Rule exec[[ CPPLibId ID1 '{' ID2 (',' Exprs)? '}' ';' Stmts]] = sequential(exec[[ CPPLibId ID1 '{' ID2 (',' Exprs)? '}' ';' ]], exec[[ Stmts ]]) 
//Otherwise
Rule exec[[ CPPVarDecl Stmts]] = sequential(exec[[CPPVarDecl]], exec[[ Stmts]])

//Rule exec[[ CPPLibId ID1 '{' ID2 ',' Exprs '}' ';']] = 
////	TODO type
//	assign(bound(id[[ ID1 ]]),
//	allocate-index thread-activate thread-joinable postpone-after-effect
////    		lookup(assigned(bound("_std")), \"CPPLibId\"),
//            supply(assigned(bound(id[[ ID2 ]])), tuple
//           (eval[[ Exprs ]]))
//	)
//
//Rule exec[[ CPPLibId ID1 '{' ID2 '}' ';']] = 
//	assign(bound(id[[ ID1 ]]),
//	allocate-index thread-activate thread-joinable postpone-after-effect
////    	lookup(assigned(bound("_std")), \"CPPLibId\"),
//            supply(assigned(bound(id[[ ID2 ]])), tuple
//           ())
//	)
Rule exec[[ CPPLibId ID ';' ]] = ()
Rule initialisations-local[[ CPPVarDecl Stmts? ]] = initialise[[ CPPVarDecl ]], initialisations-local[[ Stmts? ]]
Rule declarations-local[[ CPPVarDecl Stmts? ]] = declare[[ CPPVarDecl ]], declarations-local[[ Stmts? ]]
//
//Rule initialisations-local[[ CPPStmt ]] = ()
//Rule declarations-local[[ CPPStmt ]] = ()
//
//Rule initialise[[ CPPVarDecl ]] = ()
//Rule declare[[ CPPVarDecl ]] = var-declare[[ CPPVarDecl]]
